{"note":"Don't delete this file! It's used internally to help with page regeneration.","name":"MessagePack for Perl","google":"","tagline":"MessagePack serializer for Perl","body":"# NAME\r\n\r\nData::MessagePack - MessagePack serialising/deserialising\r\n\r\n# SYNOPSIS\r\n\r\n    use Data::MessagePack;\r\n\r\n    my $mp = Data::MessagePack->new();\r\n    $mp->canonical->utf8->prefer_integer if $needed;\r\n\r\n    my $packed   = $mp->pack($dat);\r\n    my $unpacked = $mp->unpack($dat);\r\n\r\n# DESCRIPTION\r\n\r\nThis module converts Perl data structures to MessagePack and vice versa.\r\n\r\n# ABOUT MESSAGEPACK FORMAT\r\n\r\nMessagePack is a binary-based efficient object serialization format.\r\nIt enables to exchange structured objects between many languages like\r\nJSON.  But unlike JSON, it is very fast and small.\r\n\r\n## ADVANTAGES\r\n\r\n- PORTABLE\r\n\r\nThe MessagePack format does not depend on language nor byte order.\r\n\r\n- SMALL IN SIZE\r\n\r\n    say length(JSON::XS::encode_json({a=>1, b=>2}));   # => 13\r\n    say length(Storable::nfreeze({a=>1, b=>2}));       # => 21\r\n    say length(Data::MessagePack->pack({a=>1, b=>2})); # => 7\r\n\r\nThe MessagePack format saves memory than JSON and Storable format.\r\n\r\n- STREAMING DESERIALIZER\r\n\r\nMessagePack supports streaming deserializer. It is useful for\r\nnetworking such as RPC.  See [Data::MessagePack::Unpacker](http://search.cpan.org/perldoc?Data::MessagePack::Unpacker) for\r\ndetails.\r\n\r\nIf you want to get more information about the MessagePack format,\r\nplease visit to [http://msgpack.org/](http://msgpack.org/).\r\n\r\n# METHODS\r\n\r\n- `my $packed = Data::MessagePack->pack($data[, $max_depth]);`\r\n\r\nPack the $data to messagepack format string.\r\n\r\nThis method throws an exception when the perl structure is nested more\r\nthan $max\\_depth levels(default: 512) in order to detect circular\r\nreferences.\r\n\r\nData::MessagePack->pack() throws an exception when encountering a\r\nblessed perl object, because MessagePack is a language-independent\r\nformat.\r\n\r\n- `my $unpacked = Data::MessagePack->unpack($msgpackstr);`\r\n\r\nunpack the $msgpackstr to a MessagePack format string.\r\n\r\n- `my $mp = Data::MesssagePack->new()`\r\n\r\nCreates a new MessagePack instance.\r\n\r\n- `$mp = $mp->prefer_integer([ $enable ])`\r\n- `$enabled = $mp->get_prefer_integer()`\r\n\r\nIf _$enable_ is true (or missing), then the `pack` method tries a\r\nstring as an integer if the string looks like an integer.\r\n\r\n- `$mp = $mp->canonical([ $enable ])`\r\n- `$enabled = $mp->get_canonical()`\r\n\r\nIf _$enable_ is true (or missing), then the `pack` method will output\r\npacked data by sorting their keys. This is adding a comparatively high\r\noverhead.\r\n\r\n- `$mp = $mp->utf8([ $enable ])`\r\n- `$enabled = $mp->get_utf8()`\r\n\r\nIf _$enable_ is true (or missing), then the `pack` method will\r\napply `utf8::encode()` to all the string values.\r\n\r\nIn other words, this property tell `$mp` to deal with __text strings__.\r\nSee [perlunifaq](http://search.cpan.org/perldoc?perlunifaq) for the meaning of __text string__.\r\n\r\n- `$packed = $mp->pack($data)`\r\n- `$packed = $mp->encode($data)`\r\n\r\nSame as `Data::MessagePack->pack()`, but properties are respected.\r\n\r\n- `$data = $mp->unpack($data)`\r\n- `$data = $mp->decode($data)`\r\n\r\nSame as `Data::MessagePack->unpack()`, but properties are respected.\r\n\r\n# Configuration Variables (DEPRECATED)\r\n\r\n- $Data::MessagePack::PreferInteger\r\n\r\nPacks a string as an integer, when it looks like an integer.\r\n\r\nThis variable is __deprecated__.\r\nUse `$msgpack->prefer_integer` property instead.\r\n\r\n# SPEED\r\n\r\nThis is a result of `benchmark/serialize.pl` and `benchmark/deserialize.pl`\r\non my SC440(Linux 2.6.32-23-server \\#37-Ubuntu SMP).\r\n(You should benchmark them with __your__ data if the speed matters, of course.)\r\n\r\n    -- serialize\r\n    JSON::XS: 2.3\r\n    Data::MessagePack: 0.24\r\n    Storable: 2.21\r\n    Benchmark: running json, mp, storable for at least 1 CPU seconds...\r\n          json:  1 wallclock secs ( 1.00 usr +  0.01 sys =  1.01 CPU) @ 141939.60/s (n=143359)\r\n            mp:  1 wallclock secs ( 1.06 usr +  0.00 sys =  1.06 CPU) @ 355500.94/s (n=376831)\r\n      storable:  1 wallclock secs ( 1.12 usr +  0.00 sys =  1.12 CPU) @ 38399.11/s (n=43007)\r\n                 Rate storable     json       mp\r\n    storable  38399/s       --     -73%     -89%\r\n    json     141940/s     270%       --     -60%\r\n    mp       355501/s     826%     150%       --\r\n\r\n    -- deserialize\r\n    JSON::XS: 2.3\r\n    Data::MessagePack: 0.24\r\n    Storable: 2.21\r\n    Benchmark: running json, mp, storable for at least 1 CPU seconds...\r\n          json:  0 wallclock secs ( 1.05 usr +  0.00 sys =  1.05 CPU) @ 179442.86/s (n=188415)\r\n            mp:  0 wallclock secs ( 1.01 usr +  0.00 sys =  1.01 CPU) @ 212909.90/s (n=215039)\r\n      storable:  2 wallclock secs ( 1.14 usr +  0.00 sys =  1.14 CPU) @ 114974.56/s (n=131071)\r\n                 Rate storable     json       mp\r\n    storable 114975/s       --     -36%     -46%\r\n    json     179443/s      56%       --     -16%\r\n    mp       212910/s      85%      19%       --\r\n\r\n# CAVEAT\r\n\r\n## Unpacking 64 bit integers\r\n\r\nThis module can unpack 64 bit integers even if your perl does not support them\r\n(i.e. where `perl -V:ivsize` is 4), but you cannot calculate these values\r\nunless you use `Math::BigInt`.\r\n\r\n# TODO\r\n\r\n- Error handling\r\n\r\nMessagePack cannot deal with complex scalars such as object references,\r\nfilehandles, and code references. We should report the errors more kindly.\r\n\r\n- Streaming deserializer\r\n\r\nThe current implementation of the streaming deserializer does not have internal\r\nbuffers while some other bindings (such as Ruby binding) does. This limitation\r\nwill astonish those who try to unpack byte streams with an arbitrary buffer size\r\n(e.g. `while(read($socket, $buffer, $arbitrary_buffer_size)) { ... }`).\r\nWe should implement the internal buffer for the unpacker.\r\n\r\n# FAQ\r\n\r\n- Why does Data::MessagePack have pure perl implementations?\r\n\r\nmsgpack C library uses C99 feature, VC++6 does not support C99. So pure perl version is needed for VC++ users.\r\n\r\n# AUTHORS\r\n\r\nTokuhiro Matsuno\r\n\r\nMakamaka Hannyaharamitu\r\n\r\ngfx\r\n\r\n# THANKS TO\r\n\r\nJun Kuriyama\r\n\r\nDan Kogai\r\n\r\nFURUHASHI Sadayuki\r\n\r\nhanekomu\r\n\r\nKazuho Oku\r\n\r\nshohex\r\n\r\n# LICENSE\r\n\r\nThis library is free software; you can redistribute it and/or modify\r\nit under the same terms as Perl itself.\r\n\r\n# SEE ALSO\r\n\r\n[http://msgpack.org/](http://msgpack.org/) is the official web site for the  MessagePack format.\r\n\r\n[Data::MessagePack::Unpacker](http://search.cpan.org/perldoc?Data::MessagePack::Unpacker)\r\n\r\n[AnyEvent::MPRPC](http://search.cpan.org/perldoc?AnyEvent::MPRPC)\r\n"}